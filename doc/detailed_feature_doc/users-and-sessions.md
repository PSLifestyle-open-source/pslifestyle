# Users and sessions

## Overview

The application distinguishes 2 types of users:

- Anonymous users
- Authenticated users

Both of those types can use the core functionality of the application, which is to fill the questionnaire, create
the plan and give feedback.

The benefit of becoming an authenticated user is that the answers and plan are stored permanently, unless user decides
to delete its account (such action deletes all user data), as well as more personalized experience provided to the user.

Authenticated users also can receive special roles, which allow them to access the "Management Panel", where they can
perform further actions (defined based on the roles they own).

However, from the data model point of view, those types are separated entities, stored in separated collections.

## Anonymous users

When user opens the app and is not logged in already, it's considered as an anonymous user.

Their data are stored under `anonymousUsers` collection, where the ID is randomly generated UUID v4.

They are allowed to interact with the application the same way as authenticated users,
with exception that they will not be able to access data they generated (answered questionnaire, action plan)
once they close their browser tab with the application, as their data is stored only
in [session storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) of the browser.

Anonymous users also have their "anonymous session ID" stored under "anonId" field in Anon Session state store,
which is then persisted to "anonSession" session storage field.

After anonymous user fills the questionnaire and creates action plan, they get an opportunity to get upgraded (
ascended),
what means they can create an account (using their email address) and connect the data they already created with that
newly created account. This way, they will be able to access their results and action plan whenever when they come back
to the application and login to their account.

## Authenticated users

When user is logged in (has email + session token
stored `auth` [local storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage),
which can be then used by Authed Session state store), it is considered as an authenticated user.

Their data are stored under `users` collection, where the ID is a hashed email address of the user.

Authenticated users have their data stored in the session storage the same way as anonymous users, allowing the
application to behave the same way for both types of users. However, in case of authenticated users
the data generated is also fetched from the database (if email + session token are valid) when the
application is loaded and fed to the same state stores, for the purpose of presenting to users their data
whenever they want to access them.

Authenticated users also have a possibility to delete their account, which will result in their user data,
as well as the other data they generated, to be immediately removed from the system.

The login happens using magic link mechanism. More about it [below](#login-process)

## Session initialization

The purpose of session initiation is to generate unique ID, which allows us to store all data generated by single user
together, as well as assign them to the [campaigns](./campaign.md) user decided to participate (to open campaign link).

### Anonymous user

#### Establishing new anonymous session ID

If user doesn't have established anonymous session, new one will be established by sending request to the
backend, `/initializeUser` endpoint.

If there was a problem during initialization of the session, the application still should work, and the requests to
generate the session ID should be sent later, at the moment when it will be actually needed (for example, after
finishing the questionnaire).

If initialization was successful, received anon session ID will be stored to the "anonId" field of Anon Session
state store by the frontend app, and it will continue with [country/redirect handling](#country--redirect-handling).

```mermaid
sequenceDiagram
    title Anonymous user session initiation when no Anonymous Session ID exists
    participant User
    participant Frontend
    participant Backend
    participant Database

    User ->> Frontend: Open the web application
    activate Frontend
    Frontend ->> Frontend: Anon session ID not existing in the app
    Note right of Frontend: Include campaign ID if user opened the app via campaign link
    Frontend ->> Backend: Send request to /initializeUser endpoint without anon ID
    activate Backend
    Note right of Backend: Also campaign ID must be included, if provided
    Backend ->> Database: Generate new anon session ID and create the entity with that ID in the DB.
    Database ->> Backend: Return creation result

    break when Database returned error
        Backend ->> Frontend: Return error
        Frontend ->> User: Let user progress, request for session ID if not existing later
    end
    Backend ->> Database: Fetch details of all campaigns assigned to the session
    Database ->> Backend: Return campaigns
    Backend ->> Frontend: Return details about available countries and redirect destination for the user and new anon session Id
    deactivate Backend

    Frontend ->> Frontend: Set received Anon session ID to "anonId" in AnonSession Store
    Frontend ->> Frontend: Set received allowed countries to "allowedCountries" in Location Store if received
    Frontend ->> Frontend: Pre-select country if only single allowed country returned by backend, or display country selection to user
    Frontend ->> Frontend: Redirect user to either homepage or test page
    deactivate Frontend
```

#### Using existing anonymous session ID

If user already has `anonId` in `anonSession` session storage which is managed by Anon Session state store,
it will be sent to the `/initializeUser` endpoint, which will verify whether such session exists.

If there was a problem during initialization of the session, the application still should work, and the requests to
validate/generate the session ID should be sent later, at the moment when it will be actually needed (for example, after
finishing the questionnaire).

If the session by the ID will not be found, new session ID will be returned and `downgrade` flag returned. Frontend
in that case will assign new session ID, and it will continue
with [country/redirect handling](#country--redirect-handling).

If session by the ID was found, it will immediately continue with and it will continue
with [country/redirect handling](#country--redirect-handling).

If session exists, [successful flow](#successful-response-from-initializeuser) will be followed.

```mermaid
sequenceDiagram
    title Anonymous user session initiation when Anonymous Session ID already exists
    participant User
    participant Frontend
    participant Backend
    participant Database

    User ->> Frontend: Open/refresh the web application
    activate Frontend
    Frontend ->> Frontend: Anon session ID exists in the app
    Note right of Frontend: Include campaign ID if user opened the app via campaign link
    Frontend ->> Backend: Send request to /initializeUser endpoint with anon ID
    activate Backend
    Backend ->> Database: Check if session with received ID exists
    Database ->> Backend: Return result of finding
    break when Database returned error
        Backend ->> Frontend: Return error
        Frontend ->> User: Let user progress, request for session ID if not existing later
    end
    alt Session found
        Backend ->> Database: Update user with campaign ID if this one wasn't belonging to the user before
        Database ->> Backend: Return update result
        Backend ->> Database: Fetch details of all campaigns assigned to the session
        Database ->> Backend: Return campaigns
        Backend ->> Frontend: Return details about available countries and redirect destination for the user
    else Session not found
        Note right of Backend: Also campaign ID must be included, if provided
        Backend ->> Database: Generate new anon session ID and create the entity with that ID in the DB.
        Database ->> Backend: Return creation result

        break when Database returned error
            Backend ->> Frontend: Return error
            Frontend ->> User: Let user progress, request for session ID if not existing later
        end
        Backend ->> Database: Fetch details of all campaigns assigned to the session
        Database ->> Backend: Return campaigns
        Backend ->> Frontend: Return details about available countries and redirect destination for the user, downgrade flag and new anon session Id
    end
    deactivate Backend

    alt Session was downgraded
        Frontend ->> Frontend: Set received Anon session ID to "anonId" in AnonSession Store
    end
    Frontend ->> Frontend: Set received allowed countries to "allowedCountries" in Location Store if received
    Frontend ->> Frontend: Pre-select country if only single allowed country returned by backend, or display country selection to user
    Frontend ->> Frontend: Redirect user to either homepage or test page
    deactivate Frontend
```

### Authenticated user

If user is authenticated (`user` is set inside `auth` local storage), request is sent to `/initializeUser` endpoint with
user's email and session token, to check if those are valid.

In case of failure of processing the request (for example, due to timeout or DB failure), user will NOT be logged out or
forbidden from using the app. All endpoints used for the interaction with user-specific data implement the session
token validation, and if it's not valid/it's expired, such actions will be blocked and user logged out at that point.

If the token is not valid or expired, the endpoint will generate new anonymous session ID and return `downgrade` flag.
In such case, frontend app will log out user automatically, and then assign received new anonymous session ID and
continue
with [country/redirect handling](#country--redirect-handling).

If token is valid, frontend app will immediately continue with [country/redirect handling](#country--redirect-handling).

```mermaid
sequenceDiagram
    title Anonymous user session initiation when Anonymous Session ID already exists
    participant User
    participant Frontend
    participant Backend
    participant Database

    User ->> Frontend: Open/refresh the web application
    activate Frontend
    Frontend ->> Frontend: User data (email/session token) are in the application
    Note right of Frontend: Include campaign ID if user opened the app via campaign link
    Frontend ->> Backend: Send request to /initializeUser endpoint with email+session token
    activate Backend
    Backend ->> Backend: Check if session token is valid
    break Session token is invalid
        Backend ->> Backend: Jump into "User not found" part under
    end
    Backend ->> Database: Check if user entity exists in the database
    Database ->> Backend: Return result of finding
    break when Database returned error
        Backend ->> Frontend: Return error
        Frontend ->> User: Let user progress, validate session token later
    end
    alt User found
        Backend ->> Database: Update user with campaign ID if this one wasn't belonging to the user before
        Database ->> Backend: Return update result
        Backend ->> Database: Fetch details of all campaigns assigned to the session
        Database ->> Backend: Return campaigns
        Backend ->> Frontend: Return details about available countries and redirect destination for the user
    else User not found
        Note right of Backend: Also campaign ID must be included, if provided
        Backend ->> Database: Generate new anon session ID and create the entity with that ID in the DB.
        Database ->> Backend: Return creation result

        break when Database returned error
            Backend ->> Frontend: Return error
            Frontend ->> User: Let user progress, request for session ID if not existing later
        end
        Backend ->> Database: Fetch details of all campaigns assigned to the session
        Database ->> Backend: Return campaigns
        Backend ->> Frontend: Return details about available countries and redirect destination for the user, downgrade flag and new anon session Id
    end
    deactivate Backend

    alt Session was downgraded
        Frontend ->> Frontend: Set received Anon session ID to "anonId" in AnonSession Store
    end
    Frontend ->> Frontend: Set received allowed countries to "allowedCountries" in Location Store if received
    Frontend ->> Frontend: Pre-select country if only single allowed country returned by backend, or display country selection to user
    Frontend ->> Frontend: Redirect user to either homepage or test page
    deactivate Frontend
```

### Country / redirect handling

After the response comes from `/initializeUser` and frontend handles the session-related stuff of the response
(downgrade, setting session ID, etc.), the shared part is to handle received available countries list and redirect
destination.

These fields are affected based on one or more [campaigns](./campaign.md) assigned to the user's session.

#### Allowed Countries

List of allowed countries returned by the endpoint will be set to the "allowedCountries" field of Location Store.

If list of allowed countries is empty, user will be able to use any country supported by the application and will be
presented country+language selection.

The same applies if list of allowed countries contains multiple country codes, but then user will be able to selected
only one of allowed countries.

If the list of allowed countries includes only **one** country code, that country and its default language will
be automatically set to the Location Store, without displaying country+language selection to the user.

#### Redirect destination

The response also includes redirect destination, defining where user should get redirected to after the
session initialization.

By default, (whether there is campaign or not), the value will be set to "homepage", which means that user will be
redirected to the homepage.

However, if any campaign is configured to value "test", then this setting takes over and user will be redirected
directly to the questionnaire.

**_However, this is only applicable if user is on homepage, to prevent user losing progress on page refresh_**

## Login process

The login process is done using so-called "magic link" mechanism, which utilizes token in the URL, which URL is sent to
the user via email message.

When user wants to log in, they go to login page where they provide their email address, which is then stored in
"magicLinkEmail" field of Authed Session state store (which then persists it under "auth" field of local storage).

Then, request is sent to the backend (`/requestLink` endpoint), which will either create new user entity
(if there is no entity for received email address), or it fetches the existing one, and then assigns following data
to that user entity:

- anonymous session ID has assigned while trying to log in
- Pseudorandom magic token
- Date of token generation
- Setting flag "linkUsed" to false

and sends the URL including generated magic link via email to the user.

When user clicks the received link, it gets redirected to `/checklogin` page, including the magic token.

At that moment, the email stored in `magicLinkEmail` field is combined with received magic link token, and sent to the
`/checkLink` endpoint. If the `magicLinkEmail` value is empty, or backend will not be able to resolve that combination,
or token is expired, frontend will inform user about that and ask to provide the email address which they used to log
in.

If the email address and magic link token match, several steps will be done happening:

1. Magic link gets used - `linkUsed` flag gets set to true
2. If user came from [user ascending](#user-ascending-upgrade-from-anonymous-to-authenticated-user), the data will
   get assigned to the authenticated user
3. If user still has the old data model (pre-december 2024), the data will get upgraded to version 1.

The endpoint also will verify whether user has answered questionnaire and created the plan.

As a response, the endpoint will return session token and information where user should get redirected to after login:

- Result page - When user has answered questionnaire, but not created plan
- Plan page - When user has both answered questionnaire and created the plan
- Test page - When no answers and plan were created

```mermaid
sequenceDiagram
    title Request Magic link URL
    participant User
    participant Frontend
    participant Backend
    participant Database
    participant Email Gateway

    User ->> Frontend: Open login page, type email address and submit
    Note right of Frontend: "ascend" field with answers and plan might be included, if it's the ascend process
    Frontend ->> Backend: Call `/requestLink` endpoint with anon ID and email address
    Backend ->> Database: Check if entity for hashed email address already exists
    Database ->> Backend: Returns result
    alt User doesn't exist
        Backend ->> Database: Create new user entity
    end

    Backend ->> Database: Generate and assign magic link data to the user
    Database ->> Backend: Return update result
    Backend -->> Email Gateway: Send email to user with URL containing magic link token
    Email -->> User: Deliver email with the URL
    Backend ->> Frontend: Return processing result
    Frontend ->> User: Display error or success depending on the result of process
```

```mermaid
sequenceDiagram
    title Check magic link
    participant User
    participant Frontend
    participant Backend
    participant Database

    User ->> Frontend: Click the link from received email, gets redirected to "/checklink" page
    Frontend ->> Frontend: Check if magicLinkEmail is stored in the state
    alt magicLinkEmail is not stored
        Frontend ->> User: Ask user to provide email address used when requested the link
        User ->> Frontend: Provide the email address and submit
    end

    Frontend ->> Backend: Send email address + magic link token to `/checkLink` endpoint
    Backend ->> Database: Try to find user by hashed email address
    Database ->> Backend: Return user
    Backend ->> Backend: Check if magic link token matches to the one stored for user and is not expired or used already
    break when User not found or token expired, used or not matching
        Backend ->> Frontend: Return error
        Frontend ->> User: Show error and ask user to provide email address used when requested link
    end

    Backend ->> Database: Set magic link token as used and copy campaign IDs from <br />anonymous user session user logged in to the authenticated user entity
    Database ->> Backend: Return update result
    Backend ->> Database: Merge ascended user data to the user
    Database ->> Backend: Return update result
    Backend ->> Database: Upgrade data model if old used by the user
    Database ->> Backend: Return update result

    Backend ->> Backend: Generate session token
    Backend ->> Database: Fetch user again
    Database ->> Backend: Return user data
    Backend ->> Backend: Check whether user has answers and plan, and decide to which page user should be redirected after login
    Backend ->> Frontend: Return session token and redirect destination information
    Frontend ->> Frontend: Set email address + session token to `user` field of Authed Session Store
    Frontend ->> User: Show user the page as a logged in user. Redirect to the page provided by backend
```

## User ascending (upgrade from anonymous to authenticated user)

Once anonymous users answers the questionnaire and creates the action plan, they get an opportunity to provide their
email address, which will initiate the "ascending process". It works almost the same as
the [login process](#login-process).

The difference is that in this case request to `/requestLink` endpoint does not only include anonymous session ID and
provided email address, but also "ascend" object field, which includes both answers and plan data.

Answers and plan are then persisted to the `unauthenticatedUsers` Firestore collection, with hashed email address
provided by the user as an ID of the entity.

Then, when `/checkLink` endpoint is called, and it will authenticate the user, those data will be moved to the
actual user entity under `users` collection.

For the visual flow, follow diagrams from [login process](#login-process).

## Roles

An authenticated user might be assigned to one of roles, which extends the functionality of the app, providing more
features as well as enables basic management. New "Management Panel" page gets enabled for those users.

![Management Panel menu item](./images/users-and-sessions/management-panel-menu-item.png)

![Management Panel page](./images/users-and-sessions/management-panel-page.png)

### Campaign manager role

Campaign manager role enables users to create and see statistics for [campaign](campaign.md) links they create.

This role has the following options:

- countries: list of country codes for which campaigns can be created/seen.

Role structure under the user:

```json
{
  "name": "CAMPAIGN_MANAGER",
  "options": {
    "countries": ["FI", "DE", "TR"]
  }
}
```
